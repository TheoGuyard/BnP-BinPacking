The structure of the branch of price algorithm is the same whatever branching-rule, queueing method, heuristics and other parameters are chosen. It can be resumed by the following algorithm :

\begin{figure}[!ht]
	\centering
	\begin{minipage}{0.8\linewidth}
		\begin{algorithm}[H]
			\DontPrintSemicolon 
			\SetAlgoLined
			\KwIn{The items and their size $s_1,\dots,s_N$, the bin capacity $C$, an upper bound on the number of bins $B$, a precision $\epsilon$}
			\tcp{Initialization}
			Initialize an empty tree\;
			Initialize the queue with the root\;
			Initialize the column pool with an artificial column\;
			Initialize UB $\leftarrow B$\;
			Initialize LB $\leftarrow \ceil[\Big]{\sum s_i/C}$\;
			Process a root heuristic to find a better UB (see \ref{heuristic-root})\;
			\tcp{Tree exploration}
			\While{the queue is non-empty}{
				Pop the first node in the queue\;
				Proceed the node according to the branching rule set (see \ref{ryan-foster}, \ref{generic} and \ref{node-process})\;
				Find the branching variable and add the two child nodes to the queue\;
				Process a tree heuristic to tighten UB (see \ref{heuristic-tree})\;
				Update LB and UB with the solution found by the node or by the heuristic\;
				Cut branches that cannot improve the upper bound\;
				\If{$|UB-LB|<\epsilon$}{return the best solution associated to UB}
			}
			\caption{Branch and Price}
		\end{algorithm}
	\end{minipage}
\end{figure}
\noindent In the following, the simplest steps of the BnP are explained. The heuristics, the branching method and the node processing will have a dedicated section to be explained. \\

\noindent\textbf{Column management :}

The column pool contains all the columns which are created by the subproblems. We need to add an artificial column which allow the master problem to always be feasible. This artificial column contains all the objects and have a very high cost. If the solution of a master problem contains this artificial column, we know that the master problem is infeasible because of the branching rules. Before each node processing, we will create a local node pool containing only the patterns satisfying the branching rules of the node in order to create a solution satisfying the current branching rules. In order to save speed and memory space, the column pool is global to all nodes and each node will have its proper node pool which is a filter on the global column pool. When a new pattern is created in a subproblem, it is added to the node pool and to the global column pool.  \\

\noindent\textbf{Initial bounds :}

We could have set the initial bound at $UB = + \infty$ and $LB = -\infty$ but better initial bound can be found. Indeed, we can at least assume that the total number of bin used will be at most the number of items. Thus, we can set $B = N$. The integer relaxation of \eqref{BPP-classic} gives also a lower bound for the integer \eqref{BPP-classic} : we can set $LB = \ceil[\Big]{\sum s_i/C}$ \cite{sadykov2013bin}. \\

\noindent\textbf{Queuing method :}

In the while loop, we always choose the first node in the queue but the nodes won't always been stored in the same order in the queue. When adding the two child nodes to the queue, two methods can be used. The first one puts the new nodes at the beginning of the queue (LIFO) in order to proceed a Deep-First-Search in the tree. The second method is to put the new nodes at the end of the queue (FIFO) in order to proceed a Breadth-First-Search. The LIFO method will allow to find quickly good upper bounds but it will cut branches more deeply in the tree. The FIFO method will allow to cut branches at a high level in the tree but will be slower to get good bounds. The best exploration method depends on the structure of the problem and in general, there is no one better than the other. An hybrid exploration of the tree can also be done. First, the LIFO method is set in order to find quickly a good upper-bound. Once this upper bound has been found, the queuing strategy switch to FIFO in order to explore the tree with a Breadth-First-Search. This method aims to find quickly an upper bound and then cut branches high in the tree. If a root heuristic is computed, then the Hybrid method is just like the LIFO method. \\

\noindent\textbf{Feasible solution handling :}

After the node processing, it is possible that the solution given is integer. In this case, we can see if this solution improve the current UB and if it is the case, we can update the value of UB. We also choose the best lower bound among all those of the nodes in order to update the global LB. This allow to see how close the algorithm is from the solution by bounding the optimal solution by LB and UB at each node processing. \\

\noindent\textbf{Tree pruning :}

Once the bounds are updated, we take a look at the nodes left in the queue. If a node has a lower bound larger than UB, then this node can't improve the current best solution. Thus, we can stop the exploration of the branch after this node. When $UB \simeq LB$, then the current best solution can not be improved and correspond to the optimal solution of \eqref{BPP-classic}. If the queue becomes empty while $UB \neq LB$, this means that either the problem has no solution or that $\epsilon$ is too small regarding to numerical errors. The method to branch, process a node, to run heuristics before and within the tree will be explained in the following sections. Then, we will evaluate the BnP with some performance criteria.